---
title: "DifferentialAnalysesPigBAL"
author: "Arianne Richard"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intro

This script picks up where "clustering all.Rmd" left off. Note: Moving forward, likely better to move subclustering to the clustering script. To be done later.

This script is for running differential analyses between conditions. Specifically, we will be looking for differential abundance of cells within each cluster, as well as differential expression of cells within each cluster, according to treatment condition. There are 4 conditions: PBS, Ad-HA/NP, Ad-HA/NP+Ad-IL1b, pH1N1. There are male and female mice for each group, which we will include as a covariate. Male and female are almost completely confounded with sets of runs, so we are unable to account for both of these, and anyways it would likely be over-fitted. We will just use sex as a covariate, acknowledging that there are some sources of technical variation we aren't getting rid of, but fortunately these are not confounded with biological condition and so just add noise to the data.

# Loading the data

```{r}
library(SingleCellExperiment)
library(DropletUtils)
library(scran)
library(scater)
library(uwot)
library(biomaRt)
library(scds)
library(batchelor)
library(bluster)

load('ongoing_full_clustered.RData')

## for sanity checking as we go, we'll also look at pre-merge sce_all expression
sce_all$cluster <- sce_all_corrected$cluster
```


# Differential abundance analysis

This analysis will be run using a negative binomial test. As mentioned above, we will account here for sex while testing differential abundance between conditions. Run membership is nearly completely overlapping with sex and was actually taken into account when performing batch correction before clustering, so we won't do anything more about run membership in these analyses.

We also need to account for the sorting strategy that was used. For this reason, we need to split the data into the sorted populations of CD172a+CD16+ FSC/SSC for macrophages, CD4+, CD8b+, CD3negCD16negCD172aneg cells before looking for differential abundance within these groups. To this end, we need to split the CD4 and CD8 T cells in clusters that contained both. We will achieve this by subclustering.

## Subclustering

In order to run subclustering, we start by subsetting cells in the cluster of interest. In an ideal world, CD4 and CD8 T cell-associated genes would dominate the highly variable genes and enable unsupervised sub-clustering to separate the cell types. Unfortunately, this is often not the case. We therefore need to supervise the clustering. To this end, we pull out CD4 and CD8B genes that encode the markers used for sorting and use a zero-inflated Kendall's Tau correlation metric implemented in SCHOT to identify the top genes among the highly variable genes correlated with these markers. We then use this filtered list for subclustering.

We'll start with cluster 14.

```{r}

c14 <- sce_all_corrected$cluster == '14'

CD4 <- counts(sce_all)['ENSSSCG00000000687',c14]
CD8 <- counts(sce_all)['ENSSSCG00000008213',c14]

library(scHOT)
varmod14 <- modelGeneVar(sce_all[,c14], block=sce_all[,c14]$run)
vargenes14 <- getTopHVGs(varmod14, n=1000)

CD4corr <- vector('numeric', length(vargenes14))
CD8corr <- CD4corr
for(i in 1:length(vargenes14)){
  CD4corr[i] <- weightedZIKendall(exprs(sce_all)['ENSSSCG00000000687', c14],
                               exprs(sce_all)[vargenes14[i], c14]
  )
  CD8corr[i] <- weightedZIKendall(exprs(sce_all)['ENSSSCG00000008213', c14],
                               exprs(sce_all)[vargenes14[i], c14]
  )
}

top <- vargenes14[c(which(CD4corr > 0.07),which(CD8corr > 0.07))]
top <- c(top, 'ENSSSCG00000000687', 'ENSSSCG00000008213')
top <- top[!duplicated(top)]

set.seed(100)
sce_all_14 <- fastMNN(sce_all[,c14], batch=sce_all[,c14]$run, subset.row = top, get.variance = TRUE, k=10)

set.seed(200)
sce_all_14_clust <- clusterCells(sce_all_14,
                                        use.dimred="corrected",
                                        BLUSPARAM=SNNGraphParam(k=10, 
                                                                type="jaccard",
                                                                cluster.fun="fast_greedy"))

table(sce_all_14_clust)
sce_all_14$cluster <- sce_all_14_clust
clust14 <- rep(0, times=ncol(sce_all_corrected))
clust14[c14] <- sce_all_14_clust
sce_all_corrected$subclust14 <- clust14
plotUMAP(sce_all_corrected[,c14], colour_by="subclust14", point_size=0.3)

CD4CD8 <- rownames(sce_all)[rowData(sce_all)$Symbol %in% c('CD4', 'CD8B')]
plotExpression(sce_all_14, features=CD4CD8, x='cluster', exprs_values='reconstructed')

premerge14 <- sce_all[,c14]
premerge14$cluster <- sce_all_14_clust
plotExpression(premerge14, features=CD4CD8, x='cluster')

```

Unfortunately, cluster 14 does not subcluster well, even in a supervised manner, into  CD4+ and CD8+ groups. We've tried several different mixtures of parameters and it just doesn't split. In fact, expression of CD4 and CD8 is more of a continuum in this cluster instead of bimodal as well. 

Let's eyeball whether there are different proportions of cells in this cluster by condition.

```{r}

props <- prop.table(table(sce_all_corrected$cluster, sce_all_corrected$Sample), margin=2)['14',]
proptab <- annot[,c('sample', 'Condition', 'Sex')]
proptab$props <- props[rownames(proptab)]

ggplot(data=proptab, aes(x=Condition, y=props)) +
  geom_boxplot() +
  geom_point(aes(col=Sex), position='jitter')


```

So this doesn't appear to be associated with condition. (Two of the pH1N1 values are very low, but one is high, and they are not segregated by sex.)  We may need to just leave this cluster out of our DA analysis groupings.

Next we do Cluster 18.

```{r}

c18 <- sce_all_corrected$cluster == '18'

CD4 <- counts(sce_all)['ENSSSCG00000000687',c18]
CD8 <- counts(sce_all)['ENSSSCG00000008213',c18]


library(scHOT)
varmod18 <- modelGeneVar(sce_all[,c18], block=sce_all[,c18]$run)
vargenes18 <- getTopHVGs(varmod18, n=1000)

CD4corr <- vector('numeric', length(vargenes18))
CD8corr <- CD4corr
for(i in 1:length(vargenes18)){
  CD4corr[i] <- weightedZIKendall(exprs(sce_all)['ENSSSCG00000000687', c18],
                               exprs(sce_all)[vargenes18[i], c18]
  )
  CD8corr[i] <- weightedZIKendall(exprs(sce_all)['ENSSSCG00000008213', c18],
                               exprs(sce_all)[vargenes18[i], c18]
  )
}

top <- vargenes18[c(which(CD4corr > 0.1),which(CD8corr > 0.1))]
top <- c(top, 'ENSSSCG00000000687', 'ENSSSCG00000008213')
top <- top[!duplicated(top)]

set.seed(100)
sce_all_18 <- fastMNN(sce_all[,c18], batch=sce_all[,c18]$run, subset.row = top, get.variance = TRUE)

set.seed(200)
sce_all_18_clust <- clusterCells(sce_all_18,
                                        use.dimred="corrected",
                                        BLUSPARAM=SNNGraphParam(k=20, 
                                                                type="jaccard",
                                                                cluster.fun="fast_greedy"))

table(sce_all_18_clust)
sce_all_18$cluster <- sce_all_18_clust
clust18 <- rep(0, times=ncol(sce_all_corrected))
clust18[c18] <- sce_all_18_clust
sce_all_corrected$subclust18 <- clust18
plotUMAP(sce_all_corrected[,c18], colour_by="subclust18", point_size=0.3)

CD4CD8 <- rownames(sce_all)[rowData(sce_all)$Symbol %in% c('CD4', 'CD8B')]
plotExpression(sce_all_18, features=CD4CD8, x='cluster', exprs_values='reconstructed')

premerge18 <- sce_all[,c18]
premerge18$cluster <- sce_all_18_clust
plotExpression(premerge18, features=CD4CD8, x='cluster')

```

This subclusters nicely. So let's change cluster 18 labels to 18a and 18b to reflect the subsetting. 

```{r}
sce_all_18_clust <- as.character(sce_all_18_clust)
sce_all_18_clust[sce_all_18_clust == '1'] <- '18a'
sce_all_18_clust[sce_all_18_clust == '2'] <- '18b'
cs <- as.character(sce_all_corrected$cluster)
cs[c18] <- sce_all_18_clust
sce_all_corrected$cluster <- cs
```

And cluster 20. Note that here we reduce the k nearest neighbours examined because the number of cells is so low.

```{r}

c20 <- sce_all_corrected$cluster == '20'

CD4 <- counts(sce_all)['ENSSSCG00000000687',c20]
CD8 <- counts(sce_all)['ENSSSCG00000008213',c20]


library(scHOT)
varmod20 <- modelGeneVar(sce_all[,c20], block=sce_all[,c20]$run)
vargenes20 <- getTopHVGs(varmod20, n=1000)

CD4corr <- vector('numeric', length(vargenes20))
CD8corr <- CD4corr
for(i in 1:length(vargenes20)){
  CD4corr[i] <- weightedZIKendall(exprs(sce_all)['ENSSSCG00000000687', c20],
                               exprs(sce_all)[vargenes20[i], c20]
  )
  CD8corr[i] <- weightedZIKendall(exprs(sce_all)['ENSSSCG00000008213', c20],
                               exprs(sce_all)[vargenes20[i], c20]
  )
}

top <- vargenes20[c(which(CD4corr > 0.10),which(CD8corr > 0.10))]
top <- c(top, 'ENSSSCG00000000687', 'ENSSSCG00000008213')
top <- top[!duplicated(top)]

set.seed(100)
sce_all_20 <- fastMNN(sce_all[,c20], batch=sce_all[,c20]$run, subset.row = top, get.variance = TRUE, k=9)

set.seed(200)
sce_all_20_clust <- clusterCells(sce_all_20,
                                        use.dimred="corrected",
                                        BLUSPARAM=SNNGraphParam(k=9, 
                                                                type="jaccard",
                                                                cluster.fun="fast_greedy"))

table(sce_all_20_clust)
sce_all_20$cluster <- sce_all_20_clust
clust20 <- rep(0, times=ncol(sce_all_corrected))
clust20[c20] <- sce_all_20_clust
sce_all_corrected$subclust20 <- clust20
plotUMAP(sce_all_corrected[,c20], colour_by="subclust20", point_size=0.3)

CD4CD8 <- rownames(sce_all)[rowData(sce_all)$Symbol %in% c('CD4', 'CD8B')]
plotExpression(sce_all_20, features=CD4CD8, x='cluster', exprs_values='reconstructed')

premerge20 <- sce_all[,c20]
premerge20$cluster <- sce_all_20_clust
plotExpression(premerge20, features=CD4CD8, x='cluster')
```

This clustering did a decent job except for 3 rogue cells that appear to be in the wrong cluster. They must have some similarities to the others. We'll go with this subclustering and change the labels to 20a and 20b.

```{r}

sce_all_20_clust <- as.character(sce_all_20_clust)
sce_all_20_clust[sce_all_20_clust == '1'] <- '20a'
sce_all_20_clust[sce_all_20_clust == '2'] <- '20b'
cs <- as.character(sce_all_corrected$cluster)
cs[c20] <- sce_all_20_clust
sce_all_corrected$cluster <- cs

```

Finally we would like to subcluster cluster 9 as it looked as though this was made of 2 mutually exclusive cell types, one expressing CD3E/CD8A and the other with more KLRB1 and RORC. Here we will just be guided by the data and go for an unsupervised split to see what we get.

```{r}
c9 <- sce_all_corrected$cluster == '9'
varmod9 <- modelGeneVar(sce_all[,c9], block=sce_all[,c9]$run)
vargenes9 <- getTopHVGs(varmod9, n=2000)

set.seed(100)
sce_all_9 <- fastMNN(sce_all[,c9], batch=sce_all[,c9]$run, subset.row = vargenes9, get.variance = TRUE)

set.seed(200)
sce_all_9_clust <- clusterCells(sce_all_9,
                                        use.dimred="corrected",
                                        BLUSPARAM=SNNGraphParam(k=20, 
                                                                type="jaccard",
                                                                cluster.fun="fast_greedy"))

table(sce_all_9_clust)
sce_all_9$cluster <- sce_all_9_clust
clust9 <- rep(0, times=ncol(sce_all_corrected))
clust9[c9] <- sce_all_9_clust
sce_all_corrected$subclust9 <- clust9
plotUMAP(sce_all_corrected[,c9], colour_by="subclust9", point_size=0.3)

genes <- rownames(sce_all)[rowData(sce_all)$Symbol %in% c('CD8A', 'RORC', 'CD3E', 'KLRB1', 'CD8B')]
# note CD4 was not in the list of HVGs
plotExpression(sce_all_9, features=genes, x='cluster', exprs_values='reconstructed')


```

This yields 3 subclusters, one which appears to be mainly CD3E/CD8A+, one which appears to have high KLRB1 and RORC, and the other which is intermediate and likely marked by other genes. We'll go with this level of unsupervised subclustering so that we can extract the T cells and will have to think about the identities of the other subclusters later as well. 

```{r}

sce_all_9_clust <- as.character(sce_all_9_clust)
sce_all_9_clust[sce_all_9_clust == '1'] <- '9a'
sce_all_9_clust[sce_all_9_clust == '2'] <- '9b'
sce_all_9_clust[sce_all_9_clust == '3'] <- '9c'
cs <- as.character(sce_all_corrected$cluster)
cs[c9] <- sce_all_9_clust
sce_all_corrected$cluster <- cs

```


Now we take our 25 clusters and split them according to major cell types (and whether we need to exclude them for other reasons).


```{r}
## first look at marker genes for sorting

sce_all$cluster <- sce_all_corrected$cluster

plotExpression(sce_all_corrected, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD4'], x='cluster', exprs_values='reconstructed')
plotExpression(sce_all, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD4'], x='cluster')

plotExpression(sce_all_corrected, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD8B'], x='cluster', exprs_values='reconstructed')
plotExpression(sce_all, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD8B'], x='cluster')

plotExpression(sce_all_corrected, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD163'], x='cluster', exprs_values='reconstructed')
plotExpression(sce_all, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD163'], x='cluster')

plotExpression(sce_all_corrected, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD14'], x='cluster', exprs_values='reconstructed')
plotExpression(sce_all, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD14'], x='cluster')

plotExpression(sce_all_corrected, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD3D'], x='cluster', exprs_values='reconstructed')
plotExpression(sce_all, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD3D'], x='cluster')

plotExpression(sce_all_corrected, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD3E'], x='cluster', exprs_values='reconstructed')
plotExpression(sce_all, features=rownames(sce_all)[rowData(sce_all)$Symbol == 'CD3E'], x='cluster')

```

From this, we determine that the following clusters fall into each category. Of note, our differential abundance analyses will take place within categories that are smaller or the same size as those used for sorting. In this way, the sorting and binning won't play a role in our results.

CD4: 7, 10, 18b, 20a

CD8: 6, 9a, 18a, 20b

Macrophage/Monocyte/DC: 1, 4, 8, 13, 15

B: 2, 3, 12, 16

This leaves clusters 9b, 9c, 14, 19 and 21 to be removed without consideration, as well as clusters 5, 11 and 17, which were determined to be either doublet or poor quality. 

```{r}

CD4s <- sce_all_corrected[,sce_all_corrected$cluster %in% c('7', '10', '18b', '20a')]

CD8s <- sce_all_corrected[,sce_all_corrected$cluster %in% c('6', '9a', '18a', '20b')]

MMDs <- sce_all_corrected[,sce_all_corrected$cluster %in% c('1', '4', '8', '13', '15')]

Bs <- sce_all_corrected[,sce_all_corrected$cluster %in% c('2', '3', '12', '16')]

subsets <- list(CD4s=CD4s, CD8s=CD8s, MMDs=MMDs, Bs=Bs)

```

And we run our DA tests. We'll consider a change in abundance with any treatment versus PBS in an ANODEV-like analysis.

```{r}
library(edgeR)

DA <- lapply(subsets, function(x){
  abundances <- table(x$cluster, x$Sample)
  abundances <- unclass(abundances)
  anno <- annot[colnames(abundances),]
  y.ab <- DGEList(abundances, samples=anno)
  ## may want to filter out really low abundance clusters 20a and 20b - come back to this
  y.ab$samples$Sex <- factor(y.ab$samples$Sex)
  y.ab$samples$Condition <- factor(y.ab$samples$Condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1'))
  design <- model.matrix(~Sex + Condition, y.ab$samples)
  y.ab <- estimateDisp(y.ab, design, trend="none")
  summary(y.ab$common.dispersion)
  plotBCV(y.ab, cex=1)
  fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
  summary(fit.ab$var.prior)
  summary(fit.ab$df.prior)
  plotQLDisp(fit.ab, cex=1)
  res <- glmQLFTest(fit.ab, coef=3:5)
  restab <- res$table
  restab$FDR <- p.adjust(restab$PValue)
  return(restab)
})

DA
```

Interestingly, the only strong effect here is on the proportion of Treg in with vaccine + IL1b. Let's plot it to have a look.

```{r}
## proportion of total cells
props <- prop.table(table(sce_all_corrected$cluster, sce_all_corrected$Sample), margin=2)['10',]
proptab <- annot[,c('sample', 'Condition', 'Sex')]
proptab$props <- props[rownames(proptab)]

ggplot(data=proptab, aes(x=Condition, y=props)) +
  geom_boxplot() +
  geom_point(aes(col=Sex), position='jitter')

## proportion of CD4s
props <- prop.table(table(CD4s$cluster, CD4s$Sample), margin=2)['10',]
proptab <- annot[,c('sample', 'Condition', 'Sex')]
proptab$props <- props[rownames(proptab)]

ggplot(data=proptab, aes(x=Condition, y=props)) +
  geom_boxplot() +
  geom_point(aes(col=Sex), position='jitter')

```

# Differential expression analysis

Based on our examinations in the clustering script, we exclude cluster 5 as low quality and cluster 17 as doublets. After consultation, we are also fairly convinced that cluster 11 is also doublets due to the co-expression of macrophage and B cell markers, so we will exclude this one as well. I am reluctant to remove any other suspected doublets because doublet detection is so fraught in a complex data set such as this one. 

```{r}

sce_filt <- sce_all_corrected

### should directly plot abundances of these by condition before removing

sce_filt <- sce_filt[,!sce_filt$cluster %in% c('5', '17', '11')]

plotUMAP(sce_filt, color_by='cluster')

```

Now we test for differential abundance. This analysis will be run as a pseudobulk analysis, pooling counts from all of the cells within each cluster for each sample before treating like bulk RNAseq data. Differential expression will then be analysed for each cluster. For this first pass, we will run what is effectively an ANOVA for each cluster to ask whether any condition deviates from the others. 

```{r}

sce_all_filt <- sce_all[,colnames(sce_filt)]
sce_all_filt$cluster <- sce_filt$cluster

summed <- aggregateAcrossCells(sce_all_filt, 
    id=colData(sce_all_filt)[,c("cluster", "Sample")])

library(edgeR)
library(scran)

summed.filt <- summed[,summed$ncells >= 10]

y <- DGEList(counts=counts(summed.filt), samples=colData(summed.filt))
y <- calcNormFactors(y)
y$samples$condition <- factor(y$samples$condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1'))

## need to break down this code into composite functions so can change the filtering - at the moment a small number of contaminating cells are driving the results
de.results.any <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$cluster,
    design=~sex + factor(condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1')),
    coef=3:5,
    condition=summed.filt$condition
)
## note that this has messed with the cluster order, effectively alphabetizing the clusters

## post-hoc look at fits and differences
for(i in 1:length(de.results.any)){
  plotBCV(metadata(de.results.any[[i]])$y, main=names(de.results.any)[i])
  plotQLDisp(metadata(de.results.any[[i]])$fit, main=names(de.results.any)[i])
  plotMDS(metadata(de.results.any[[i]])$y, 
          labels=metadata(de.results.any[[i]])$y$samples$sex, 
          col=c('black', 'blue', 'turquoise', 'red')[as.numeric(factor(metadata(de.results.any[[i]])$y$samples$condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1')))], 
          main=names(de.results.any)[i])
}

for(i in 1:length(de.results.any)){
  de.results.any[[i]]$symbol <- rowData(sce_all_filt)[rownames(de.results.any[[i]]), 'Symbol']
  colnames(de.results.any[[i]])[1:3] <- c('logFC_Ad.HA.NP', 'logFC_Ad.HA.NP.Ad.IL1b', 'logFC_pH1N1')
  write.table(de.results.any[[i]], 
              file=paste0('Jan2023analysis/DE_all_cluster_', names(de.results.any)[i], '.txt'), 
              sep='\t', quote=FALSE)
}
lapply(de.results.any, function(x){head(x[order(x$PValue),])})

#look at clusters that were skipped
metadata(de.results.any)$failed
```

Sex (and perhaps confounded run set) really dominate the variance here. There aren't big shifts by condition but there are a handful of genes in most clusters that significantly vary in one or more conditions. Also clusters 19 and 20 failed due to not having enough cells in each sample/cluster split. These may come up in differential abundance testing and are possibly very interesting for that reason.

We would now like to formally test each condition against PBS and generate a list of genes significant in each of these. Our formal analysis will ultimately improve on this one-by-one approach, but it's a good place to see where we are at with the data for discussion.

```{r}
de.results.AdHANP <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$cluster,
    design=~sex + factor(condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1')),
    coef=3,
    condition=summed.filt$condition
)


for(i in 1:length(de.results.AdHANP)){
  de.results.AdHANP[[i]]$symbol <- rowData(sce_all_filt)[rownames(de.results.AdHANP[[i]]), 'Symbol']
  write.table(de.results.AdHANP[[i]], 
              file=paste0('March2023analysis/DE_AdHANP_cluster_', names(de.results.AdHANP)[i], '.txt'), 
              sep='\t', quote=FALSE)
}
lapply(de.results.AdHANP, function(x){head(x[order(x$PValue),])})


de.results.AdHANPAdIL1b <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$cluster,
    design=~sex + factor(condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1')),
    coef=4,
    condition=summed.filt$condition
)

for(i in 1:length(de.results.AdHANPAdIL1b)){
  de.results.AdHANPAdIL1b[[i]]$symbol <- rowData(sce_all_filt)[rownames(de.results.AdHANPAdIL1b[[i]]), 'Symbol']
  write.table(de.results.AdHANPAdIL1b[[i]], 
              file=paste0('Jan2023analysis/DE_AdHANPAdIL1b_cluster_',
                          names(de.results.AdHANPAdIL1b)[i], '.txt'), 
              sep='\t', quote=FALSE)
}
lapply(de.results.AdHANPAdIL1b, function(x){head(x[order(x$PValue),])})


de.results.pH1N1 <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$cluster,
    design=~sex + factor(condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1')),
    coef=5,
    condition=summed.filt$condition
)

for(i in 1:length(de.results.pH1N1)){
  de.results.pH1N1[[i]]$symbol <- rowData(sce_all_filt)[rownames(de.results.pH1N1[[i]]), 'Symbol']
  write.table(de.results.pH1N1[[i]], 
              file=paste0('Jan2023analysis/DE_pH1N1_cluster_', names(de.results.pH1N1)[i], '.txt'), 
              sep='\t', quote=FALSE)
}
lapply(de.results.pH1N1, function(x){head(x[order(x$PValue),])})





```

Finally, it will be interesting to examine specifically the impact of adding IL1b to the immunization. 

```{r}
de.results.IL1b <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$cluster,
    design=~sex + factor(condition, levels=c('PBS', 'Ad-HA/NP', 'Ad-HA/NP+Ad-IL1b', 'pH1N1')),
    contrast=c(0,0,-1,1,0),
    condition=summed.filt$condition
)

for(i in 1:length(de.results.IL1b)){
  de.results.IL1b[[i]]$symbol <- rowData(sce_all_filt)[rownames(de.results.IL1b[[i]]), 'Symbol']
  write.table(de.results.IL1b[[i]], 
              file=paste0('Jan2023analysis/DE_IL1b_cluster_', names(de.results.IL1b)[i], '.txt'), 
              sep='\t', quote=FALSE)
}
lapply(de.results.IL1b, function(x){head(x[order(x$PValue),])})



```

Follow-up will involve making e.g. heatmaps or plots of specific genes, perhaps easiest after discussion. A few quick figures are depicted below for sanity checking.

```{r}
IFI6 <- 'ENSSSCG00000034570'
CCL5 <- 'ENSSSCG00000017705'

plot_resid <- function(y, clust, regress_out, split_by, gene, ...){
  
  loggene <- cpm(y, log=TRUE)[gene,y$samples$cluster==clust]
  mod <- lm(loggene~y$samples[y$samples$cluster==clust, regress_out])
  res <- resid(mod)
  boxplot(res~y$samples[y$samples$cluster==clust,split_by], xlab='', ylab=gene, ...)
  stripchart(res~y$samples[y$samples$cluster==clust,split_by], 
             method = "jitter", pch=20, vertical=TRUE, add=TRUE)
}


for(i in 1:length(de.results.any)){
  plot_resid(y, clust=names(de.results.any)[i], regress_out='sex', split_by='condition', IFI6, 
             main=paste('Cluster', names(de.results.any)[i]))
}

for(i in 1:length(de.results.any)){
  plot_resid(y, clust=names(de.results.any)[i], regress_out='sex', split_by='condition', CCL5, 
             main=paste('Cluster', names(de.results.any)[i]))
}

```


# Cluster annotation

Based on manual annotation from the clustered data performed using the generated tables and our shiny app, we'll give the clusters more intuitive names that can be transposed into figures.

*to be done*

```{r}

## add in cluster names as sce_all_filt$named_cluster

```




# Wrapping up

Save everything

```{r}
sessionInfo()
save(list=ls(), file='ongoing_full_diff.RData') 
```



